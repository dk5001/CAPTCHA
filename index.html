<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.js"></script>
    <script src="https://unpkg.com/ml5@1/dist/ml5.min.js"></script>
    <script src="p5.comfyui-helper.js"></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CAPTCHA 2.0</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        width: 100%;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #000000;
        font-family: Arial, sans-serif;
      }

      #interface-container {
        position: relative;
        width: 800px;
        height: 900px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      /* Checkbox Interface */
      #checkbox-interface {
        position: absolute;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10;
      }

      .checkbox-container {
        width: 480px;
        height: 120px;
        background-color: #f0f0f0;
        border-radius: 10px;
        display: flex;
        align-items: center;
        padding: 0 20px;
      }

      .checkbox-wrapper {
        display: flex;
        align-items: center;
        flex: 1;
      }

      .checkbox {
        width: 30px;
        height: 30px;
        border: 2px solid #000;
        background-color: #000;
        margin-right: 40px;
        position: relative;
        cursor: pointer;
      }

      .checkbox.checked::after {
        content: "";
        position: absolute;
        top: 5px;
        left: 5px;
        width: 20px;
        height: 20px;
        background-color: #fff;
      }

      .checkbox-text {
        font-size: 24px;
        color: #000;
      }

      .cog-icon {
        width: 100px;
        height: 100px;
        margin-left: auto;
      }

      /* Question Interface */
      #question-interface {
        position: absolute;
        width: 100%;
        height: 100%;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
      }

      .question-container {
        width: 480px;
        background-color: #f0f0f0;
        border-radius: 10px;
        padding: 30px;
        text-align: center;
      }

      .question-text {
        font-size: 28px;
        color: #000;
        margin-bottom: 30px;
      }

      .question-input {
        width: 100%;
        padding: 12px;
        font-size: 20px;
        border: 2px solid #000;
        border-radius: 5px;
        margin-bottom: 20px;
      }

      .question-back-button {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background-color: rgba(10, 10, 10, 0.6);
        color: white;
        padding: 10px 20px;
        border-radius: 25px;
        cursor: pointer;
        border: 2px solid #646464;
        outline: 2px solid white;
      }
      
      /* Grid Interface */
      #grid-interface {
        position: absolute;
        width: 100%;
        height: 100%;
        display: none;
        flex-direction: column;
        align-items: center;
      }

      .header {
        width: 100%;
        height: 160px;
        background-color: #646464;
        display: flex;
        justify-content: center;
        align-items: center;
        margin-bottom: 40px;
      }

      .header-text {
        color: white;
        font-size: 36px;
        text-align: center;
      }

      .grid-container {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }

      .grid-item {
        width: 200px;
        height: 200px;
        border: 3px solid white;
        cursor: pointer;
        position: relative;
      }

      .grid-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .grid-item.selected::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(100, 0, 0, 0.4);
      }

      .shuffle-button {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background-color: rgba(10, 10, 10, 0.6);
        color: white;
        padding: 10px 20px;
        border-radius: 25px;
        cursor: pointer;
        border: 2px solid #646464;
        outline: 2px solid white;
      }

      .back-button {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background-color: rgba(10, 10, 10, 0.6);
        color: white;
        padding: 10px 20px;
        border-radius: 25px;
        cursor: pointer;
        border: 2px solid #646464;
        outline: 2px solid white;
      }

      .countdown {
        position: absolute;
        top: 180px;
        width: 100%;
        text-align: center;
        color: black;
        font-size: 24px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .countdown.visible {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <div id="interface-container">
      <!-- Checkbox Interface -->
      <div id="checkbox-interface">
        <div class="checkbox-container">
          <div class="checkbox-wrapper">
            <div class="checkbox" id="rational-checkbox"></div>
            <div class="checkbox-text">Want to see your face?</div>
          </div>
          <img src="cog.png" class="cog-icon" alt="Cog icon">
        </div>
      </div>

      <!-- Question Interface -->
      <div id="question-interface">
        <div class="question-container">
          <div class="question-text">I imagine myself as a ___</div>
          <input type="text" id="user-input" class="question-input" placeholder="Type your answer here">
          <div style="font-size: 18px; color: #6f6f6f; margin-top: 10px;">Press enter to move on</div>
        </div>
        <div class="question-back-button" id="question-back-button">Back</div>
      </div>

      <!-- Grid Interface -->
      <div id="grid-interface">
        <div class="header">
          <div class="header-text">Choose one face that resonates</div>
        </div>
        <div class="countdown" id="countdown"></div>
        <div class="grid-container" id="grid-container">
          <!-- Grid items will be added dynamically -->
        </div>
        <div class="shuffle-button" id="shuffle-button">Shuffle</div>
        <div class="back-button" id="back-button">Back</div>
      </div>
    </div>

    <!-- <script>
      // Replace the entire script section at the bottom of your file -->

    <script>
      // Configuration
      const config = {
        gridSize: 3,
        imageCount: 9, // Total number of available images
        checkboxWaitTime: 1500, // 1 second wait time
        countdownDuration: 3000, // 3 seconds countdown
      };

      // State variables
      let selectedTile = null;
      let countdownTimer = null;
      let selectionTime = 0;
      let images = [];
      let displayedImages = [];
      let video;
      let capturedImage = null;
      let p5Instance;
      let lastGeneratedImageUrl = null;
      let userInput = ""; 
      
      // Debug function to help troubleshoot
      function debug(message) {
        console.log(`DEBUG: ${message}`);
      }
      
      // Load all images
      function preloadImages() {
        debug("Preloading images");
        for (let i = 1; i <= config.imageCount; i++) {
          let paddedIndex = String(i).padStart(2, '0');
          let imgPath = `images/img${paddedIndex}.png`;
          images.push(imgPath);
        }
        debug(`Preloaded ${images.length} images`);
      }
      
      // Initialize the grid with random images
      function initializeGrid() {
        debug("Initializing grid");
        const gridContainer = document.getElementById('grid-container');
        gridContainer.innerHTML = '';
        
        // Shuffle the images array and take the first 9
        displayedImages = shuffleArray([...images]).slice(0, config.gridSize * config.gridSize);
        
        // Create grid items
        for (let i = 0; i < displayedImages.length; i++) {
          const gridItem = document.createElement('div');
          gridItem.className = 'grid-item';
          gridItem.dataset.index = i;
          
          const img = document.createElement('img');
          img.src = displayedImages[i];
          img.alt = `Image ${i+1}`;
          img.style.filter = 'grayscale(100%)'; // Apply black and white filter
          
          gridItem.appendChild(img);
          gridContainer.appendChild(gridItem);
          
          // Add click event
          gridItem.addEventListener('click', handleTileClick);
        }
        debug("Grid initialized with images");
            }

            function initWebcam() {
        debug("Initializing webcam");

        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
          debug("ERROR: MediaDevices.enumerateDevices() not supported in this browser");
          // Try with just getUserMedia directly as fallback
          initWebcamDirectly();
          return;
        }

        // Request permission first - this helps with device enumeration
        navigator.mediaDevices.getUserMedia({ video: true })
          .then(function(stream) {
            debug("Initial camera permission granted - now will enumerate devices");
            // Stop this initial stream - we'll create a new one after selecting the right camera
            stream.getTracks().forEach(track => track.stop());
            
            // Now enumerate all devices
            return navigator.mediaDevices.enumerateDevices();
          })
          .then(function(devices) {
            debug("Available media devices:");
            
            // Find video devices (webcams)
            const videoDevices = devices.filter(device => device.kind === 'videoinput');
            if (videoDevices.length === 0) {
              debug("No video input devices found!");
              initWebcamDirectly();
              return;
            }
            
            // Log all video devices
            videoDevices.forEach((device, index) => {
              debug(`Webcam ${index}: ${device.label || 'Camera ' + (index + 1)} (${device.deviceId})`);
            });
            
            // Always use camera index 0 if available
            const cameraIndex = 0;
            const selectedCamera = videoDevices[cameraIndex].deviceId;
            debug(`Selecting camera: ${cameraIndex} (${selectedCamera})`);
            
            // Request access to the selected camera
            return navigator.mediaDevices.getUserMedia({
              video: {
          deviceId: {exact: selectedCamera},
          width: { ideal: 1280 },
          height: { ideal: 720 }
              }
            });
          })
          .then(function(stream) {
            debug("Camera access granted");
            setupVideoElement(stream);
          })
          .catch(function(error) {
            debug("Error during camera selection: " + error.message);
            debug("Falling back to default camera");
            initWebcamDirectly();
          });
            }
            
            function initWebcamDirectly() {
        debug("Trying to initialize webcam directly without device selection");
        navigator.mediaDevices.getUserMedia({ 
          video: { 
            width: { ideal: 1280 },
            height: { ideal: 720 }
          } 
        })
        .then(function(stream) {
          debug("Default webcam access granted");
          setupVideoElement(stream);
        })
        .catch(function(error) {
          debug("Error with ideal constraints: " + error.message);
          debug("Trying with minimal constraints");
          navigator.mediaDevices.getUserMedia({ video: true })
            .then(function(stream) {
              debug("Minimal webcam access granted");
              setupVideoElement(stream);
            })
            .catch(function(err) {
               debug("CRITICAL ERROR: Cannot access any webcam: " + err.message);
            });
        });
            }

            function setupVideoElement(stream) {
        video = document.createElement('video');
        video.srcObject = stream;
        video.autoplay = true;
        video.muted = true;
        
        // Apply rotation: 90 degrees clockwise + horizontal flip
        video.style.transform = 'scaleX(-1) rotate(90deg)';
        
        // Apply CSS filter to make the video black and white
        video.style.filter = 'grayscale(100%)';
        
        // Ensure video is ready to use
        video.addEventListener('loadedmetadata', function() {
          debug("Video metadata loaded");
          video.play().catch(e => debug("Video play error: " + e.message));
        });
        
        // Add a button to toggle between cameras (for testing)
        addCameraSwitchButton();
            }

      function addCameraSwitchButton() {
        // Create or reuse the switch button
        let switchButton = document.getElementById('camera-switch-btn');
        if (!switchButton) {
          switchButton = document.createElement('button');
          switchButton.id = 'camera-switch-btn';
          switchButton.textContent = 'Switch Camera';
                    switchButton.style.position = 'fixed';
                    switchButton.style.bottom = '12px';
                    switchButton.style.right = '12px';
                    switchButton.style.zIndex = '2147483647'; // very high
                    switchButton.style.padding = '10px 14px';
                    switchButton.style.backgroundColor = '#ff5722'; // bright orange
                    switchButton.style.color = 'white';
                    switchButton.style.border = '2px solid #fff';
                    switchButton.style.borderRadius = '6px';
                    switchButton.style.fontSize = '14px';
                    switchButton.style.boxShadow = '0 6px 18px rgba(0,0,0,0.6)';
          document.body.appendChild(switchButton);
        } else {
          switchButton.style.display = 'block';
          // make visible and prominent
          switchButton.style.backgroundColor = '#ff5722';
          switchButton.style.color = 'white';
          switchButton.style.zIndex = '2147483647';
          if (!document.body.contains(switchButton)) document.body.appendChild(switchButton);
        }

        // Attach handler once
        if (switchButton.dataset && switchButton.dataset.hasHandler === '1') return;
        switchButton.dataset = switchButton.dataset || {};
        switchButton.dataset.hasHandler = '1';

        switchButton.addEventListener('click', function() {
                debug('Camera switch button clicked');

          // Small status UI
          let statusEl = document.getElementById('camera-switch-status');
          if (!statusEl) {
            statusEl = document.createElement('div');
            statusEl.id = 'camera-switch-status';
            statusEl.style.position = 'fixed';
            statusEl.style.bottom = '48px';
            statusEl.style.right = '10px';
            statusEl.style.zIndex = '10000';
            statusEl.style.padding = '6px 8px';
            statusEl.style.backgroundColor = 'rgba(0,0,0,0.6)';
            statusEl.style.color = 'white';
            statusEl.style.borderRadius = '4px';
            statusEl.style.fontSize = '12px';
            document.body.appendChild(statusEl);
          }
          statusEl.textContent = 'Attempting camera switch...';

          // Determine current camera id
          let currentCameraId = null;
          if (video && video.srcObject) {
            const tracks = video.srcObject.getVideoTracks();
            if (tracks.length) currentCameraId = tracks[0].getSettings().deviceId;
          }

          navigator.mediaDevices.enumerateDevices()
            .then(function(devices) {
              const videoDevices = devices.filter(d => d.kind === 'videoinput');
              debug('Found ' + videoDevices.length + ' video devices');

              if (videoDevices.length <= 1) {
                statusEl.textContent = 'No alternate camera found â€” retrying default...';
                return navigator.mediaDevices.getUserMedia({ video: true });
              }

              // Stop current stream before switching
              if (video && video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());

              let currentIndex = -1;
              if (currentCameraId) currentIndex = videoDevices.findIndex(d => d.deviceId === currentCameraId);
              let nextIndex = currentIndex === 0 ? 1 : 0;
              if (nextIndex >= videoDevices.length) nextIndex = 0;
              const nextCameraId = videoDevices[nextIndex].deviceId;
              debug('Switching to camera index: ' + nextIndex);
              statusEl.textContent = 'Switching camera...';

              return new Promise(resolve => setTimeout(() => resolve(nextCameraId), 200));
            })
            .then(function(nextCameraId) {
              if (!nextCameraId) return null;
              return navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: nextCameraId }, width: { ideal: 1280 }, height: { ideal: 720 } } });
            })
            .then(function(stream) {
              if (!stream) return;
              if (video) {
                video.srcObject = stream;
                video.play().catch(e => debug('Video play error: ' + e.message));
              } else {
                setupVideoElement(stream);
              }
              statusEl.textContent = 'Camera switched';
              setTimeout(() => statusEl.remove(), 1200);
              const activeVideos = document.querySelectorAll('.grid-item.webcam-active video');
              activeVideos.forEach(v => { v.srcObject = stream; v.play().catch(() => {}); });
            })
            .catch(function(err) {
              debug('Switch error: ' + err.message);
              // Try minimal recovery
              navigator.mediaDevices.getUserMedia({ video: true })
                .then(function(stream) {
                  if (video) { video.srcObject = stream; video.play().catch(() => {}); }
                  else { setupVideoElement(stream); }
                  statusEl.textContent = 'Recovered default camera';
                  setTimeout(() => statusEl.remove(), 1200);
                })
                .catch(function(e) {
                  debug('Recovery failed: ' + e.message);
                  statusEl.textContent = 'No camera available. Click to retry.';
                  statusEl.style.cursor = 'pointer';
                  statusEl.onclick = function() { statusEl.textContent = 'Retrying...'; statusEl.onclick = null; switchButton.click(); };
                });
            });
        });
      }

      // Shuffle array using Fisher-Yates algorithm
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }
      
      // Handle tile click
      function handleTileClick(event) {
        debug("Tile clicked");
        const allTiles = document.querySelectorAll('.grid-item');
        const clickedTile = event.currentTarget;
        
        // If the clicked tile is already selected, deselect it
        if (clickedTile.classList.contains('selected')) {
          debug("Deselecting tile");
          clickedTile.classList.remove('selected');
          clickedTile.classList.remove('webcam-active');

          // Remove webcam if it exists
          const videoElement = clickedTile.querySelector('video');
          if (videoElement) {
            videoElement.remove();
          }
          
          selectedTile = null;
          clearCountdown();
          return;
        }

        // Deselect all tiles first
        allTiles.forEach(tile => {
          tile.classList.remove('selected');
          tile.classList.remove('webcam-active');

          // Remove any existing webcam elements
          const videoElement = tile.querySelector('video');
          if (videoElement) {
            videoElement.remove();
          }
        });
        
        // Select the clicked tile
        debug("Selecting new tile");
        clickedTile.classList.add('selected');
        selectedTile = clickedTile;
        
        // Start countdown
        startCountdown(clickedTile);
      }
      
      // Start countdown timer
      function startCountdown(selectedTile) {
        debug("Starting countdown");
        const countdownElement = document.getElementById('countdown');
        countdownElement.classList.add('visible');
        
        selectionTime = Date.now();
        clearInterval(countdownTimer);
        
        countdownTimer = setInterval(() => {
          const elapsed = Date.now() - selectionTime;
          const timeLeft = Math.max(0, Math.floor((config.countdownDuration - elapsed) / 1000));
          
          countdownElement.textContent = `${timeLeft} seconds left`;
          debug(`Countdown: ${timeLeft}s left`);
          
          // At 1 second into the countdown (2 seconds left), show webcam
          if (elapsed >= 1000 && !selectedTile.classList.contains('webcam-active')) {
            debug("Activating webcam in tile");
            selectedTile.classList.add('webcam-active');
            
            // Add webcam to the selected tile
            if (video) {
              debug("Adding video element to tile");
              const videoClone = video.cloneNode(true);
              videoClone.srcObject = video.srcObject;
              videoClone.style.display = "block";
              videoClone.style.width = "100%";
              videoClone.style.height = "100%";
              videoClone.style.objectFit = "cover";
              videoClone.style.transform = "scaleX(-1) rotate(90deg)"; // Mirror and rotate
              videoClone.autoplay = true;
              videoClone.muted = true;
              videoClone.play().catch(e => debug("Video clone play error: " + e.message));

              selectedTile.querySelector('img').style.display = "none";
              selectedTile.appendChild(videoClone);
            } else {
              debug("Video element not available");
            }
          }
          
          if (timeLeft <= 0) {
            debug("Countdown finished");
            clearInterval(countdownTimer);
            captureImage(selectedTile);
          }
        }, 100);
      }

      // Capture image from webcam
      function captureImage(selectedTile) {
        debug("Capturing image");
        
        if (!video || !video.srcObject) {
          debug("Video not available for capture");
          return;
        }
        
        // Create a canvas to capture the webcam image
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        try {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          
          debug(`Canvas created: ${canvas.width} x ${canvas.height}`);
          
          // Draw the video frame to the canvas (flipped horizontally)
          context.translate(canvas.width, 0);
          context.scale(-1, 1);
          context.drawImage(video, 0, 0, canvas.width, canvas.height);
          context.rotate(Math.PI/2);

          // Draw the video frame to the canvas with the transformation applied
          context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
          
          // Convert to black and white
          const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          
          for (let i = 0; i < data.length; i += 4) {
            const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
            data[i] = gray;
            data[i + 1] = gray;
            data[i + 2] = gray;
          }
          
          context.putImageData(imageData, 0, 0);
          
          // Create an image from the canvas
          const capturedImage = new Image();
          capturedImage.onload = function() {
            // Replace the video with the captured image
            const videoElement = selectedTile.querySelector('video');
            if (videoElement) {
              videoElement.remove();
            }
            
            // Remove original image
            const originalImage = selectedTile.querySelector('img');
            if (originalImage) {
              originalImage.remove();
            }
            
            selectedTile.appendChild(capturedImage);
            selectedTile.classList.remove('webcam-active');
            
            debug("Image captured and displayed");
  
            // Get the selected original image
            const selectedImageSrc = displayedImages[selectedTile.dataset.index];
            
            // Here you would proceed to the next state
            setTimeout(() => {
              debug("Creating p5 instance for ComfyUI integration");
              createReceiptInterface(capturedImage, selectedImageSrc);
            }, 1000);
          };
          
          capturedImage.src = canvas.toDataURL('image/png');
          capturedImage.style.width = "100%";
          capturedImage.style.height = "100%";
          capturedImage.style.objectFit = "cover";
        } catch (e) {
          debug("Error during image capture: " + e.message);
        }
      }

      function startPulseAnimation() {
            const selectedGlow = document.getElementById('selected-img-glow');
            const capturedGlow = document.getElementById('captured-img-glow');
            const statusMsg = document.getElementById('generation-status');
            
            let startTime = Date.now();
            let animationFrame;
            let dotCount = 0;
            let statusMessages = [
              'Analyzing facial features',
              'Extracting key points',
              'Generating latent space',
              'Blending face attributes',
              'Applying style transfer',
              'Rendering final image'
            ];
            let currentMsgIndex = 0;
            
            function updatePulse() {
              const elapsed = Date.now() - startTime;
              
            
              // Create a sine wave with period of 2 seconds
              const intensity = Math.sin(elapsed / 2000 * Math.PI) * 0.5 + 0.5;
              
              // Apply different phases to each glow
              selectedGlow.style.backgroundColor = `rgba(255, 0, 0, ${intensity * 0.4})`;
              capturedGlow.style.backgroundColor = `rgba(255, 0, 0, ${intensity * 0.4})`;
              

              // Update the status message every 3 seconds
              if (elapsed % 3000 < 100 && elapsed > 100) {
                currentMsgIndex = (currentMsgIndex + 1) % statusMessages.length;
                dotCount = 0;
              }
              
              // Update the dots every 500ms
              if (elapsed % 500 < 100) {
                dotCount = (dotCount + 1) % 4;
              }
              

              // Update status message
              statusMsg.textContent = statusMessages[currentMsgIndex] + '.'.repeat(dotCount);
              
            
              // Continue animation
              animationFrame = requestAnimationFrame(updatePulse);
            }
            
            // Start the animation
            animationFrame = requestAnimationFrame(updatePulse);
            
            // Store the animation frame ID for later cleanup
            window.pulseAnimationFrame = animationFrame;
          }

      // Create receipt interface and p5 instance
      function createReceiptInterface(capturedImage, selectedImageSrc) {
        debug("Creating receipt interface");
        
        // Hide previous interfaces
        document.getElementById('checkbox-interface').style.display = 'none';
        document.getElementById('grid-interface').style.display = 'none';
        
        // Create receipt container
        const receiptContainer = document.createElement('div');
        receiptContainer.id = 'receipt-interface';
        receiptContainer.style.position = 'absolute';
        receiptContainer.style.width = '100%';
        receiptContainer.style.height = '100%';
        receiptContainer.style.backgroundColor = 'white';
        receiptContainer.style.display = 'flex';
        receiptContainer.style.flexDirection = 'column';
        receiptContainer.style.alignItems = 'center';
        receiptContainer.style.justifyContent = 'center';
        
        // Add loading message
        const loadingMsg = document.createElement('div');
        loadingMsg.innerHTML = `
          <h2 style="margin-bottom: 30px;">Processing Your Images</h2>
          <p style="margin-bottom: 40px;">Please wait while we generate your results...</p>
        `;
        receiptContainer.appendChild(loadingMsg);
        
        // Add container for the pulsing images
        const imagesContainer = document.createElement('div');
        imagesContainer.id = 'loading-images-container';
        imagesContainer.style.display = 'flex';
        imagesContainer.style.justifyContent = 'center';
        imagesContainer.style.gap = '40px';
        imagesContainer.style.marginTop = '20px';

        // Add selected image
        const selectedImgContainer = document.createElement('div');
        selectedImgContainer.innerHTML = `
          <h3 style="text-align: center; margin-bottom: 10px;">Selected Face</h3>
          <div id="selected-img-pulse" style="
            width: 240px;
            height: 240px;
            position: relative;
            border: 1px solid #ccc;
          ">
            <img src="${selectedImageSrc}" style="
              width: 100%;
              height: 100%;
              object-fit: cover;
              position: relative;
              z-index: 1;
            ">
            <div id="selected-img-glow" style="
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background-color: rgba(255, 0, 0, 0);
              z-index: 2;
              pointer-events: none;
            "></div>
          </div>
        `;
        
        // Add captured image
        const capturedImgContainer = document.createElement('div');
        capturedImgContainer.innerHTML = `
          <h3 style="text-align: center; margin-bottom: 10px;">Your Face</h3>
          <div id="captured-img-pulse" style="
            width: 240px;
            height: 240px;
            position: relative;
            border: 1px solid #ccc;
          ">
            <img src="${capturedImage.src}" style="
              width: 100%;
              height: 100%;
              object-fit: cover;
              position: relative;
              z-index: 1;
            ">
            <div id="captured-img-glow" style="
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background-color: rgba(255, 0, 0, 0);
              z-index: 2;
              pointer-events: none;
            "></div>
          </div>
        `;

        imagesContainer.appendChild(selectedImgContainer);
        imagesContainer.appendChild(capturedImgContainer);
        receiptContainer.appendChild(imagesContainer);
        
        // Add a status message that will update
        const statusMsg = document.createElement('div');
        statusMsg.id = 'generation-status';
        statusMsg.style.marginTop = '40px';
        statusMsg.style.fontStyle = 'italic';
        statusMsg.textContent = 'Initializing generation...';
        receiptContainer.appendChild(statusMsg);
        
        document.getElementById('interface-container').appendChild(receiptContainer);
        
        // Create a hidden canvas for p5 to use
        const p5Container = document.createElement('div');
        p5Container.id = 'p5-container';
        p5Container.style.display = 'none';
        document.body.appendChild(p5Container);

        // Start the pulsing animation
        startPulseAnimation();
        
        // Create p5 instance with a sketch function that bridges to sketch.js
        p5Instance = new p5(function(p) {
          // Store references to captured and selected images
          let p5CapturedImage;
          let p5SelectedImage;
          let workflow;
          let comfy;
          let srcImg;
          let resImg;
          let jsonFilename;
          
          p.preload = function() {
            // Load ComfyUI workflow
            workflow = p.loadJSON("latent_face_morph_workflow_controlNet_API.json");
          };
          
          p.setup = function() {
            p.createCanvas(800, 900);
            p.canvas.style.display = 'none';
            
            // Initialize ComfyUI helper
            comfy = new ComfyUiP5Helper("http://127.0.0.1:8188/");
            
            // Create source image graphics
            srcImg = p.createGraphics(800, 900);
            
            // Load the selected image
            p5SelectedImage = p.loadImage(selectedImageSrc, () => {
              debug("Selected image loaded in p5");
              
              // Create a p5 image from the capture
              p.loadImage(capturedImage.src, (loadedCaptureImg) => {
                p5CapturedImage = loadedCaptureImg;
                debug("Captured image loaded in p5");
                
                // Generate a unique filename
                jsonFilename = 'subject_' + Math.floor(100000 + Math.random() * 900000);
                
                // Start the image generation process
                requestImage();
              });
            });
          };
          
          async function requestImage() {
            debug("Requesting ComfyUI image generation");
            
            if (!p5CapturedImage) {
              debug("No captured image available");
              showErrorInReceipt();
              return;
            }
            
            // Prepare source image for generation
            srcImg.image(p5CapturedImage, 0, 0, 800, 900);
            
            // Replace the LoadImage node with our source image
            workflow[1] = comfy.image(srcImg);
            workflow[2] = comfy.image(p5SelectedImage);
            workflow[6].inputs.seed = Math.floor(Math.random() * 1e15);
            
            // Set the text prompt with user input
            let promptText = "person, black and white image";
            
            if (userInput) {
              try {
                debug("Calling prompt server with: " + userInput);
                const response = await fetch("http://127.0.0.1:8088", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ text: userInput })
                });
                
                if (response.ok) {
                  const data = await response.json();
                  if (data.prompt) {
                    promptText = data.prompt + ", black and white image";
                    debug("Received enhanced prompt: " + promptText);
                  } else {
                    promptText = `${userInput}, black and white image`;
                  }
                } else {
                  debug("Prompt server returned status: " + response.status);
                  promptText = `${userInput}, black and white image`;
                }
              } catch (e) {
                debug("Error calling prompt server: " + e.message);
                promptText = `${userInput}, black and white image`;
              }
            }
            
            debug(`Setting prompt text to: "${promptText}"`);
            workflow[10].inputs.text = promptText;
            
            debug("Generated random seed: " + workflow[6].inputs.seed);

             // Add timeout to handle stuck requests
            let requestTimeout = setTimeout(() => {
              debug("ComfyUI request timed out after 120 seconds");
              showErrorInReceipt();
            }, 90000); // 1 min 30 sec timeout
            
            debug("Running ComfyUI workflow");
            comfy.run(workflow, (results, err) => {
              // Clear the timeout since we got a response
              clearTimeout(requestTimeout);
              gotImage(results, err);
            });
          }
          
          function gotImage(results, err) {
            debug("Got image results from ComfyUI");
  
            if (err) {
              debug("Error in ComfyUI generation: " + err);
              showErrorInReceipt();
              return;
            }
            
            if (!results) {
              debug("No results from ComfyUI");
              showErrorInReceipt();
              return;
            }
            
            if (results.length === 0) {
              debug("Empty results from ComfyUI");
              showErrorInReceipt();
              return;
            }
            
            if (!results[0] || !results[0].src) {
              debug("Invalid result format from ComfyUI");
              showErrorInReceipt();
              return;
            }
            
            debug("Successfully received generated image URL: " + results[0].src);
            
            // Try loading the image with a timeout
            let imageLoadTimeout = setTimeout(() => {
              debug("Image loading timed out");
              showErrorInReceipt();
            }, 30000); // 30 second timeout for image loading
            
            p.loadImage(results[0].src, 
              // Success callback
              (loadedResult) => {
                clearTimeout(imageLoadTimeout);
                resImg = loadedResult;
                debug("Generated image loaded successfully");
                
                // Update the receipt with the generated image
                updateReceiptWithResults(capturedImage, selectedImageSrc, results[0].src, jsonFilename);
              },
              // Error callback
              (err) => {
                clearTimeout(imageLoadTimeout);
                debug("Error loading generated image: " + err);
                showErrorInReceipt();
              }
            );
          }

          function showErrorInReceipt() {
            debug("Showing error in receipt interface");

            // Update the receipt to show an error message
            updateReceiptWithResults(capturedImage, selectedImageSrc, null, jsonFilename);
          }
          
        }, 'p5-container');
      }

      // Update receipt with results
      function updateReceiptWithResults(capturedImage, selectedImageSrc, generatedImageSrc, jsonFilename) {
        debug("Updating receipt with results");

        // Stop the pulse animation if it's running
        if (window.pulseAnimationFrame) {
          cancelAnimationFrame(window.pulseAnimationFrame);
          window.pulseAnimationFrame = null;
        }

        // Store the generated image URL for next round
        if (generatedImageSrc) {
          lastGeneratedImageUrl = generatedImageSrc;
          debug("Stored generated image URL for next round: " + lastGeneratedImageUrl);
        }
        
        const receiptContainer = document.getElementById('receipt-interface');
        if (!receiptContainer) return;
        
        // Clear previous content
        receiptContainer.innerHTML = '';
        
        // Set up receipt content
        receiptContainer.innerHTML = `
          <h1 style="margin-bottom: 20px;">GENERATION RESULTS</h1>
          
          <div style="width: 100%; display: flex; justify-content: center; gap: 40px; margin-bottom: 20px;">
            <div>
              <p>Date: ${new Date().toLocaleDateString()}</p>
              <p>Time: ${new Date().toLocaleTimeString()}</p>
            </div>
            <div style="font-weight: bold; font-size: 1.2em; color: #cc0000; text-align: center;">
              <p>User ID: ${jsonFilename ? jsonFilename.replace('subject_', '') : Math.floor(100000 + Math.random() * 900000)}</p>
            </div>
          </div>
          
          <hr style="width: 100%; margin: 10px 0 20px 0;">
          
          <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-bottom: 30px;">
            <div style="text-align: center;">
              <h3>Selected Image</h3>
              <img src="${selectedImageSrc}" style="width: 240px; height: 240px; object-fit: cover; border: 1px solid #ccc;">
            </div>
            
            <div style="text-align: center;">
              <h3>User Info</h3>
              <img src="${capturedImage.src}" style="width: 240px; height: 240px; object-fit: cover; border: 1px solid #ccc;">
            </div>
            
            <div style="text-align: center;">
              <h3>Generated Image</h3>
              ${generatedImageSrc 
                ? `<img src="${generatedImageSrc}" style="width: 240px; height: 240px; object-fit: cover; border: 1px solid #ccc;">` 
                : `<div style="width: 240px; height: 240px; border: 1px solid #ccc; display: flex; align-items: center; justify-content: center;">Generation failed</div>`}
            </div>
          </div>
          
          <div style="margin-top: 30px; text-align: center;">
            <p>Thank you for contributing to our collective face</p>
            <p>This project is constantly evolving to reflect our unconsciousness and biases</p>
            <button id="reset-button" style="
              background-color: #0066cc;
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: 5px;
              margin-top: 20px;
              cursor: pointer;
              font-weight: bold;
            ">Start Over</button>
          </div>
        `;
        
        // Add reset button handler
        document.getElementById('reset-button').addEventListener('click', function() {
          resetApp();
        });
      }

      // Reset app to initial state
      function resetApp() {
        debug("Resetting application");
        
        // Remove p5 instance
        if (p5Instance) {
          p5Instance.remove();
          p5Instance = null;
        }
        
        // Remove p5 container
        const p5Container = document.getElementById('p5-container');
        if (p5Container) {
          p5Container.remove();
        }
        
        // Hide receipt interface
        const receiptInterface = document.getElementById('receipt-interface');
        if (receiptInterface) {
          receiptInterface.remove();
        }
        
        // Reset checkbox state
        document.getElementById('rational-checkbox').classList.remove('checked');

        // Reset question input
        document.getElementById('user-input').value = '';
        userInput = "";
        
        // Show checkbox interface
        document.getElementById('checkbox-interface').style.display = 'flex';
        document.getElementById('question-interface').style.display = 'none';
        document.getElementById('grid-interface').style.display = 'none';
        
        // Reset grid
        selectedTile = null;
        clearCountdown();

        // Add generated image to the images array if it exists
        if (lastGeneratedImageUrl && lastGeneratedImageUrl.trim() !== '') {
          debug("Adding last generated image to the grid: " + lastGeneratedImageUrl);
          
          // If we already have the max number of images, replace a random one
          if (images.length >= config.imageCount) {
            const randomIndex = Math.floor(Math.random() * images.length);
            debug(`Replacing image at index ${randomIndex} with generated image`);
            images[randomIndex] = lastGeneratedImageUrl;
          } else {
            // Otherwise just add it
            images.push(lastGeneratedImageUrl);
          }
        }
        
        // Reinitialize grid
        initializeGrid();
      }
      
      // Clear countdown timer
      function clearCountdown() {
        clearInterval(countdownTimer);
        const countdownElement = document.getElementById('countdown');
        countdownElement.classList.remove('visible');
      }
      
      // Initialize application
      function init() {
        debug("Initializing application");
        preloadImages();
        initializeGrid();
        // Ensure switch camera button is available even if webcam init fails
        try { addCameraSwitchButton(); } catch(e) { debug('addCameraSwitchButton error: ' + e.message); }
        initWebcam();
        
        // Handle checkbox click
        document.getElementById('rational-checkbox').addEventListener('click', function() {
          debug("Checkbox clicked");
          this.classList.add('checked');
          
          // Wait for specified time before showing grid interface
          setTimeout(() => {
            debug("Transitioning to grid interface");
            document.getElementById('checkbox-interface').style.display = 'none';
            document.getElementById('question-interface').style.display = 'flex';
          }, config.checkboxWaitTime);
        });

        // Handle question input
        document.getElementById('user-input').addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            userInput = this.value.trim();
            if (userInput) {
              debug(`User input: "${userInput}"`);
              // Show grid interface
              document.getElementById('question-interface').style.display = 'none';
              document.getElementById('grid-interface').style.display = 'flex';
            }
          }
        });
        
        // Handle shuffle button click
        document.getElementById('shuffle-button').addEventListener('click', function() {
          debug("Shuffle button clicked");
          // Clear any selected tile and countdown
          selectedTile = null;
          clearCountdown();
          
          // Reinitialize grid
          initializeGrid();
        });

        // Handle question back button
        document.getElementById('question-back-button').addEventListener('click', function() {
          debug("Question back button clicked");
          document.getElementById('question-interface').style.display = 'none';
          document.getElementById('checkbox-interface').style.display = 'flex';
          
          // Reset checkbox state
          document.getElementById('rational-checkbox').classList.remove('checked');
          document.getElementById('user-input').value = ''; // Clear input
          userInput = ""; // Reset stored input
        });

        // Handle grid back button
        document.getElementById('back-button').addEventListener('click', function() {
          debug("Grid back button clicked");
          // Clear any selected tile and countdown
          selectedTile = null;
          clearCountdown();
          
          // Show question interface, hide grid interface
          document.getElementById('grid-interface').style.display = 'none';
          document.getElementById('question-interface').style.display = 'flex';
        });
      }
      
      // Start the application when DOM is loaded
      document.addEventListener('DOMContentLoaded', init);
    </script>
  </body>
</html>