<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.js"></script>
    <script src="https://unpkg.com/ml5@1/dist/ml5.min.js"></script>
    <script src="p5.comfyui-helper.js"></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CAPTCHA 2.0</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        width: 100%;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #000000;
        font-family: Arial, sans-serif;
      }

      #interface-container {
        position: relative;
        width: 800px;
        height: 900px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      /* Checkbox Interface */
      #checkbox-interface {
        position: absolute;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10;
      }

      .checkbox-container {
        width: 480px;
        height: 120px;
        background-color: #f0f0f0;
        border-radius: 10px;
        display: flex;
        align-items: center;
        padding: 0 20px;
      }

      .checkbox-wrapper {
        display: flex;
        align-items: center;
        flex: 1;
      }

      .checkbox {
        width: 30px;
        height: 30px;
        border: 2px solid #000;
        background-color: #000;
        margin-right: 40px;
        position: relative;
        cursor: pointer;
      }

      .checkbox.checked::after {
        content: "";
        position: absolute;
        top: 5px;
        left: 5px;
        width: 20px;
        height: 20px;
        background-color: #fff;
      }

      .checkbox-text {
        font-size: 24px;
        color: #000;
      }

      .cog-icon {
        width: 100px;
        height: 100px;
        margin-left: auto;
      }

      /* Grid Interface */
      #grid-interface {
        position: absolute;
        width: 100%;
        height: 100%;
        display: none;
        flex-direction: column;
        align-items: center;
      }

      .header {
        width: 100%;
        height: 160px;
        background-color: #646464;
        display: flex;
        justify-content: center;
        align-items: center;
        margin-bottom: 40px;
      }

      .header-text {
        color: white;
        font-size: 36px;
        text-align: center;
      }

      .grid-container {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }

      .grid-item {
        width: 200px;
        height: 200px;
        border: 3px solid white;
        cursor: pointer;
        position: relative;
      }

      .grid-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .grid-item.selected::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(100, 0, 0, 0.4);
      }

      .shuffle-button {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background-color: rgba(10, 10, 10, 0.6);
        color: white;
        padding: 10px 20px;
        border-radius: 25px;
        cursor: pointer;
      }

      .countdown {
        position: absolute;
        top: 180px;
        width: 100%;
        text-align: center;
        color: black;
        font-size: 24px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .countdown.visible {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <div id="interface-container">
      <!-- Checkbox Interface -->
      <div id="checkbox-interface">
        <div class="checkbox-container">
          <div class="checkbox-wrapper">
            <div class="checkbox" id="rational-checkbox"></div>
            <div class="checkbox-text">Want to see your face?</div>
          </div>
          <img src="cog.png" class="cog-icon" alt="Cog icon">
        </div>
      </div>

      <!-- Grid Interface -->
      <div id="grid-interface">
        <div class="header">
          <div class="header-text">Choose one face that resonates</div>
        </div>
        <div class="countdown" id="countdown"></div>
        <div class="grid-container" id="grid-container">
          <!-- Grid items will be added dynamically -->
        </div>
        <div class="shuffle-button" id="shuffle-button">Shuffle</div>
      </div>
    </div>

    <!-- <script>
      // Replace the entire script section at the bottom of your file -->

    <script>
      // Configuration
      const config = {
        gridSize: 3,
        imageCount: 15, // Total number of available images
        checkboxWaitTime: 1000, // 1 second wait time
        countdownDuration: 3000, // 3 seconds countdown
      };

      // State
      let selectedTile = null;
      let countdownTimer = null;
      let selectionTime = 0;
      let images = [];
      let displayedImages = [];
      let video;
      let capturedImage = null;
      let p5Instance;
      
      // Debug function to help troubleshoot
      function debug(message) {
        console.log(`DEBUG: ${message}`);
      }
      
      // Load all images
      function preloadImages() {
        debug("Preloading images");
        for (let i = 1; i <= config.imageCount; i++) {
          let paddedIndex = String(i).padStart(2, '0');
          let imgPath = `images/img${paddedIndex}.png`;
          images.push(imgPath);
        }
        debug(`Preloaded ${images.length} images`);
      }
      
      // Initialize the grid with random images
      function initializeGrid() {
        debug("Initializing grid");
        const gridContainer = document.getElementById('grid-container');
        gridContainer.innerHTML = '';
        
        // Shuffle the images array and take the first 9
        displayedImages = shuffleArray([...images]).slice(0, config.gridSize * config.gridSize);
        
        // Create grid items
        for (let i = 0; i < displayedImages.length; i++) {
          const gridItem = document.createElement('div');
          gridItem.className = 'grid-item';
          gridItem.dataset.index = i;
          
          const img = document.createElement('img');
          img.src = displayedImages[i];
          img.alt = `Image ${i+1}`;
          
          gridItem.appendChild(img);
          gridContainer.appendChild(gridItem);
          
          // Add click event
          gridItem.addEventListener('click', handleTileClick);
        }
        debug("Grid initialized with images");
      }

      function initWebcam() {
        debug("Initializing webcam");
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          navigator.mediaDevices.getUserMedia({ video: true })
            .then(function(stream) {
              debug("Webcam access granted");
                video = document.createElement('video');
                video.srcObject = stream;
                video.autoplay = true;
                video.muted = true;
                video.style.transform = 'scaleX(-1)'; // Mirror the webcam

                // Apply CSS filter to make the video black and white
                video.style.filter = 'grayscale(100%)';
              
              // Ensure video is ready to use
              video.addEventListener('loadedmetadata', function() {
                debug("Video metadata loaded");
                video.play().catch(e => debug("Video play error: " + e.message));
              });
            })
            .catch(function(error) {
              debug("Error accessing webcam: " + error.message);
            });
        } else {
          debug("MediaDevices not supported in this browser");
        }
      }
      
      // Shuffle array using Fisher-Yates algorithm
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }
      
      // Handle tile click
      function handleTileClick(event) {
        debug("Tile clicked");
        const allTiles = document.querySelectorAll('.grid-item');
        const clickedTile = event.currentTarget;
        
        // If the clicked tile is already selected, deselect it
        if (clickedTile.classList.contains('selected')) {
          debug("Deselecting tile");
          clickedTile.classList.remove('selected');
          clickedTile.classList.remove('webcam-active');

          // Remove webcam if it exists
          const videoElement = clickedTile.querySelector('video');
          if (videoElement) {
            videoElement.remove();
          }
          
          selectedTile = null;
          clearCountdown();
          return;
        }

        // Deselect all tiles first
        allTiles.forEach(tile => {
          tile.classList.remove('selected');
          tile.classList.remove('webcam-active');

          // Remove any existing webcam elements
          const videoElement = tile.querySelector('video');
          if (videoElement) {
            videoElement.remove();
          }
        });
        
        // Select the clicked tile
        debug("Selecting new tile");
        clickedTile.classList.add('selected');
        selectedTile = clickedTile;
        
        // Start countdown
        startCountdown(clickedTile);
      }
      
      // Start countdown timer
      function startCountdown(selectedTile) {
        debug("Starting countdown");
        const countdownElement = document.getElementById('countdown');
        countdownElement.classList.add('visible');
        
        selectionTime = Date.now();
        clearInterval(countdownTimer);
        
        countdownTimer = setInterval(() => {
          const elapsed = Date.now() - selectionTime;
          const timeLeft = Math.max(0, Math.floor((config.countdownDuration - elapsed) / 1000));
          
          countdownElement.textContent = `${timeLeft} seconds left`;
          debug(`Countdown: ${timeLeft}s left`);
          
          // At 1 second into the countdown (2 seconds left), show webcam
          if (elapsed >= 1000 && !selectedTile.classList.contains('webcam-active')) {
            debug("Activating webcam in tile");
            selectedTile.classList.add('webcam-active');
            
            // Add webcam to the selected tile
            if (video) {
              debug("Adding video element to tile");
              const videoClone = video.cloneNode(true);
              videoClone.srcObject = video.srcObject;
              videoClone.style.display = "block";
              videoClone.style.width = "100%";
              videoClone.style.height = "100%";
              videoClone.style.objectFit = "cover";
              videoClone.style.transform = "scaleX(-1)";
              videoClone.autoplay = true;
              videoClone.muted = true;
              videoClone.play().catch(e => debug("Video clone play error: " + e.message));

              selectedTile.querySelector('img').style.display = "none";
              selectedTile.appendChild(videoClone);
            } else {
              debug("Video element not available");
            }
          }
          
          if (timeLeft <= 0) {
            debug("Countdown finished");
            clearInterval(countdownTimer);
            captureImage(selectedTile);
          }
        }, 100);
      }

      // Capture image from webcam
      function captureImage(selectedTile) {
        debug("Capturing image");
        
        if (!video || !video.srcObject) {
          debug("Video not available for capture");
          return;
        }
        
        // Create a canvas to capture the webcam image
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        try {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          
          debug(`Canvas created: ${canvas.width} x ${canvas.height}`);
          
          // Draw the video frame to the canvas (flipped horizontally)
          context.translate(canvas.width, 0);
          context.scale(-1, 1);
          context.drawImage(video, 0, 0, canvas.width, canvas.height);
          
          // Convert to black and white
          const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          
          for (let i = 0; i < data.length; i += 4) {
            const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
            data[i] = gray;
            data[i + 1] = gray;
            data[i + 2] = gray;
          }
          
          context.putImageData(imageData, 0, 0);
          
          // Create an image from the canvas
          const capturedImage = new Image();
          capturedImage.onload = function() {
            // Replace the video with the captured image
            const videoElement = selectedTile.querySelector('video');
            if (videoElement) {
              videoElement.remove();
            }
            
            // Remove original image
            const originalImage = selectedTile.querySelector('img');
            if (originalImage) {
              originalImage.remove();
            }
            
            selectedTile.appendChild(capturedImage);
            selectedTile.classList.remove('webcam-active');
            
            debug("Image captured and displayed");
  
            // Get the selected original image
            const selectedImageSrc = displayedImages[selectedTile.dataset.index];
            
            // Here you would proceed to the next state
            setTimeout(() => {
              debug("Creating p5 instance for ComfyUI integration");
              createReceiptInterface(capturedImage, selectedImageSrc);
            }, 1000);
          };
          
          capturedImage.src = canvas.toDataURL('image/png');
          capturedImage.style.width = "100%";
          capturedImage.style.height = "100%";
          capturedImage.style.objectFit = "cover";
        } catch (e) {
          debug("Error during image capture: " + e.message);
        }
      }

      // Create receipt interface and p5 instance
      function createReceiptInterface(capturedImage, selectedImageSrc) {
        debug("Creating receipt interface");
        
        // Hide previous interfaces
        document.getElementById('checkbox-interface').style.display = 'none';
        document.getElementById('grid-interface').style.display = 'none';
        
        // Create receipt container
        const receiptContainer = document.createElement('div');
        receiptContainer.id = 'receipt-interface';
        receiptContainer.style.position = 'absolute';
        receiptContainer.style.width = '100%';
        receiptContainer.style.height = '100%';
        receiptContainer.style.backgroundColor = 'white';
        receiptContainer.style.display = 'flex';
        receiptContainer.style.flexDirection = 'column';
        receiptContainer.style.alignItems = 'center';
        receiptContainer.style.justifyContent = 'center';
        
        // Add loading message
        const loadingMsg = document.createElement('div');
        loadingMsg.innerHTML = `
          <h2>Processing Your Images</h2>
          <p>Please wait while we generate your results...</p>
        `;
        receiptContainer.appendChild(loadingMsg);
        
        document.getElementById('interface-container').appendChild(receiptContainer);
        
        // Create a hidden canvas for p5 to use
        const p5Container = document.createElement('div');
        p5Container.id = 'p5-container';
        p5Container.style.display = 'none';
        document.body.appendChild(p5Container);
        
        // Create p5 instance with a sketch function that bridges to sketch.js
        p5Instance = new p5(function(p) {
          // Store references to captured and selected images
          let p5CapturedImage;
          let p5SelectedImage;
          let workflow;
          let comfy;
          let srcImg;
          let resImg;
          let jsonFilename;
          
          p.preload = function() {
            // Load ComfyUI workflow
            workflow = p.loadJSON("latent_face_morph_workflow_controlNet_API.json");
          };
          
          p.setup = function() {
            p.createCanvas(800, 900);
            p.canvas.style.display = 'none';
            
            // Initialize ComfyUI helper
            comfy = new ComfyUiP5Helper("http://127.0.0.1:8188/");
            
            // Create source image graphics
            srcImg = p.createGraphics(800, 900);
            
            // Load the selected image
            p5SelectedImage = p.loadImage(selectedImageSrc, () => {
              debug("Selected image loaded in p5");
              
              // Create a p5 image from the capture
              p.loadImage(capturedImage.src, (loadedCaptureImg) => {
                p5CapturedImage = loadedCaptureImg;
                debug("Captured image loaded in p5");
                
                // Generate a unique filename
                jsonFilename = 'subject_' + Math.floor(100000 + Math.random() * 900000);
                
                // Start the image generation process
                requestImage();
              });
            });
          };
          
          function requestImage() {
            debug("Requesting ComfyUI image generation");
            
            if (!p5CapturedImage) {
              debug("No captured image available");
              return;
            }
            
            // Prepare source image for generation
            srcImg.image(p5CapturedImage, 0, 0, 800, 900);
            
            // Replace the LoadImage node with our source image
            workflow[1] = comfy.image(srcImg);
            workflow[2] = comfy.image(p5SelectedImage);
            workflow[6].inputs.seed = Math.floor(Math.random() * 1e15);
            debug("Generated random seed: " + workflow[6].inputs.seed);
            
            debug("Running ComfyUI workflow");
            comfy.run(workflow, gotImage);
          }
          
          function gotImage(results, err) {
            debug("Got image results from ComfyUI");
            
            if (err) {
              debug("Error in ComfyUI generation: " + err);
              showErrorInReceipt();
              return;
            }
            
            if (results && results.length > 0) {
              debug("Successfully received generated image");
              p.loadImage(results[0].src, (loadedResult) => {
                resImg = loadedResult;
                debug("Generated image loaded");
                
                // Update the receipt with the generated image
                updateReceiptWithResults(capturedImage, selectedImageSrc, results[0].src, jsonFilename);
              });
            } else {
              debug("No results from ComfyUI");
              showErrorInReceipt();
            }
          }
          
          function showErrorInReceipt() {
            // Update the receipt to show an error message
            updateReceiptWithResults(capturedImage, selectedImageSrc, null, jsonFilename);
          }
          
        }, 'p5-container');
      }

      // Update receipt with results
      function updateReceiptWithResults(capturedImage, selectedImageSrc, generatedImageSrc, jsonFilename) {
        debug("Updating receipt with results");
        
        const receiptContainer = document.getElementById('receipt-interface');
        if (!receiptContainer) return;
        
        // Clear previous content
        receiptContainer.innerHTML = '';
        
        // Set up receipt content
        receiptContainer.innerHTML = `
          <h1 style="margin-bottom: 20px;">GENERATION RESULTS</h1>
          
          <div style="width: 100%; display: flex; justify-content: space-between; margin-bottom: 20px;">
            <div>
              <p>Date: ${new Date().toLocaleDateString()}</p>
              <p>Time: ${new Date().toLocaleTimeString()}</p>
            </div>
            <div style="font-weight: bold; font-size: 1.2em; color: #cc0000;">
              <p>User ID: ${jsonFilename ? jsonFilename.replace('subject_', '') : Math.floor(100000 + Math.random() * 900000)}</p>
            </div>
          </div>
          
          <hr style="width: 100%; margin: 10px 0 20px 0;">
          
          <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-bottom: 30px;">
            <div style="text-align: center;">
              <h3>Selected Image</h3>
              <img src="${selectedImageSrc}" style="width: 240px; height: 240px; object-fit: cover; border: 1px solid #ccc;">
            </div>
            
            <div style="text-align: center;">
              <h3>User Info</h3>
              <img src="${capturedImage.src}" style="width: 240px; height: 240px; object-fit: cover; border: 1px solid #ccc;">
            </div>
            
            <div style="text-align: center;">
              <h3>Generated Image</h3>
              ${generatedImageSrc 
                ? `<img src="${generatedImageSrc}" style="width: 240px; height: 240px; object-fit: cover; border: 1px solid #ccc;">` 
                : `<div style="width: 240px; height: 240px; border: 1px solid #ccc; display: flex; align-items: center; justify-content: center;">Generation failed</div>`}
            </div>
          </div>
          
          <div style="margin-top: 30px; text-align: center;">
            <p>Thank you for contributing to our collective face</p>
            <p>This project is constantly evolving to reflect our unconsciousness and biases</p>
            <button id="reset-button" style="
              background-color: #0066cc;
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: 5px;
              margin-top: 20px;
              cursor: pointer;
              font-weight: bold;
            ">Start Over</button>
          </div>
        `;
        
        // Add reset button handler
        document.getElementById('reset-button').addEventListener('click', function() {
          resetApp();
        });
      }

      // Reset app to initial state
      function resetApp() {
        debug("Resetting application");
        
        // Remove p5 instance
        if (p5Instance) {
          p5Instance.remove();
          p5Instance = null;
        }
        
        // Remove p5 container
        const p5Container = document.getElementById('p5-container');
        if (p5Container) {
          p5Container.remove();
        }
        
        // Hide receipt interface
        const receiptInterface = document.getElementById('receipt-interface');
        if (receiptInterface) {
          receiptInterface.remove();
        }
        
        // Reset checkbox state
        document.getElementById('rational-checkbox').classList.remove('checked');
        
        // Show checkbox interface
        document.getElementById('checkbox-interface').style.display = 'flex';
        document.getElementById('grid-interface').style.display = 'none';
        
        // Reset grid
        selectedTile = null;
        clearCountdown();
        
        // Reinitialize grid
        initializeGrid();
      }
      
      // Clear countdown timer
      function clearCountdown() {
        clearInterval(countdownTimer);
        const countdownElement = document.getElementById('countdown');
        countdownElement.classList.remove('visible');
      }
      
      // Initialize application
      function init() {
        debug("Initializing application");
        preloadImages();
        initializeGrid();
        initWebcam();
        
        // Handle checkbox click
        document.getElementById('rational-checkbox').addEventListener('click', function() {
          debug("Checkbox clicked");
          this.classList.add('checked');
          
          // Wait for specified time before showing grid interface
          setTimeout(() => {
            debug("Transitioning to grid interface");
            document.getElementById('checkbox-interface').style.display = 'none';
            document.getElementById('grid-interface').style.display = 'flex';
          }, config.checkboxWaitTime);
        });
        
        // Handle shuffle button click
        document.getElementById('shuffle-button').addEventListener('click', function() {
          debug("Shuffle button clicked");
          // Clear any selected tile and countdown
          selectedTile = null;
          clearCountdown();
          
          // Reinitialize grid
          initializeGrid();
        });
      }
      
      // Start the application when DOM is loaded
      document.addEventListener('DOMContentLoaded', init);
    </script>
  </body>
</html>
